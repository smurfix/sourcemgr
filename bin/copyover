#!/bin/bash

dest=$1
src=$2
stat=$3

### bash extension
umask +rx,u=rwx || umask 022

shift; shift; if test -n "$*" ; then shift ; fi
set -e
pack=$dest/var/lib/packages
if test ! -d $pack; then pack=$dest/tmp; fi
sk=/tmp/skipped.$$
rm -f $sk
if test -z "$stat" -o "x$stat" = "x-"; then stat="$src/usr/src/STATUS" ; fi

if test -z "$src" ; then
	echo "Usage: $0 destroot srcroot [ STATUSdir [Paket..]]" >&2
	echo "Ohne Pakete: lies von stdin. STATUSdir ist normalerweise /usr/src." >&2
	exit 1
fi

if test ! -d "$pack" ; then
	echo "Verzeichnis '$pack' nicht gefunden!" >&2
	exit 1
fi

if test ! -d "$stat" ; then
	echo "Verzeichnis '$stat' nicht gefunden!" >&2
	exit 1
fi

inst() {
	a="$1"
	echo "$a ..." >&2
	if test -f $stat/legacy/$a ; then ofi=$stat/legacy/$a; else ofi=$stat/out/$a; fi
	if test -f $pack/$a && test $pack/$a -nt $ofi ; then
		: echo "$a: bereits installiert"
	elif test -f $ofi ; then
		sed -e "s|^/*||" < $ofi > /tmp/ff.$$
		( perl -e "\$src=\"$src\";" -e '
              while(<>) {
                  chop; s#/[\/\.]*$##; next if $_ eq "";
                  do { next if $k{$_}; $k{$_} = (-d $src.$_)?1:(-f _)?((-l $src.$_ )?4:3):5;
                  } until ($_ !~ s#/+([^/]+)$##)
              } foreach $i ( sort {
                       $k{$a} <=> $k{$b} or length $a <=> length $b or $a cmp $b
                   } keys %k) { print "$i\n"; }
		    ' < /tmp/ff.$$
		  tee /tmp/pack.$$ < /tmp/ff.$$ ) |
 (cd $src; cpio -pmdv $dest 2>&1 ) | tee -a $src/tmp/ilog
#( while read a ; do if test -d $src/$a ; then mkdir -p $dest/$a; else
#  cp -avu $src/$a $dest/$a; fi; done )
		rm -f /tmp/ff.$$
		mv /tmp/pack.$$ $pack/$a
	elif test -f $stat/packages/$a ; then
		$stat/bin/copyover $dest $src $stat < $stat/packages/$a
	elif test -f $stat/hosts/$a ; then
		$stat/bin/copyover $dest $src $stat < $stat/hosts/$a
	else
		echo $a: nicht gefunden
		echo $a >> $sk
	fi
	echo "... $a" >&2
}

if test -n "$*" ; then
	for x ; do
		inst "$x"
	done
else
	while read x y ; do
		test -z "$y" || x="${x}_$y"
		inst "$x"
	done
fi

if test -f $sk ; then
	cat $sk
	rm $sk
	# exit 1
fi
exit 0

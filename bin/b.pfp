#!/usr/bin/perl -w

use strict;
use warnings;
no warnings 'uninitialized';
use Carp qw(confess);
use Time::Local qw(timegm);

my $debug=1;
my @DT;

$ENV{BK_LICENSE}="ACCEPTED";
$ENV{CLOCK_DRIFT}="1";

$|=1;

use Shell qw(); ## bk prcs

sub bk {
	my @cmd = @_;

	if(defined $cmd[0]) {
		unshift(@cmd,"env",@DT,"bk");
	} else {
		shift(@cmd);
	}
	open(FP,"-|") or do {
		exec @cmd;
		exit(99);
	};
	my @res;
	while(<FP>) {
		chop;
		push(@res,$_);
	}
	close(FP) or do {
		warn $! ? "*** Error closing pipe: $!" : "Exit status $? from BK";
		return undef;
	};
	wantarray ? @res : (0+@res);
}

my $state=0;
my $who="unknown";
my $where="unknown";
my $when=time;
my $cmt; $cmt="@ARGV\n" if @ARGV;

my $dtf;
if(-f "/usr/lib/datefudge.so") {
	$dtf = "/usr/lib";
} elsif(-f "/usr/local/lib/datefudge.so") {
	$dtf = "/usr/local/lib";
} elsif(-f "/home/smurf/datefudge/datefudge.so") {
	$dtf = "/home/smurf/datefudge";
} else {
	die "No DateFudge";
}

sub isgone($) {
	my($x)=@_;
	return unless $x =~ s/#.* delete//;	# ...FOO#1.2 delete => FOO
	return unless $x =~ s#^\.\.\. //depot/(?:[-\._a-zA-Z0-9]+/)?perl/##; # //depot/perl/FOO => FOO
	unlink($x);
}

while(<STDIN>) {
	chomp; s/\s*$//;
	if($state==0 and /^Change (\d+) by (\S+?)(?:\@(\S+))? on (\S+\s\S+)$/) {
		use Time::ParseDate;

		$state=1;
		$who=$2; $where=$3;
		$when=parsedate($4,WHOLE=>1,GMT=>1,DATE_REQUIRED=>1,UK=>1,NO_RELATIVE=>1,VALIDATE=>1) or die "No time parse";
		@DT = ("LD_PRELOAD=$dtf","DATEFUDGE=".(time-$when));
		$where .= ".somewhere" unless $where =~/\./;
		push(@DT,"BK_USER=$who","BK_HOST=$where");
	} elsif($state==1 and /^$/) {
		$state=11;
	} elsif($state==12 and /^Affected files/) {
		chop $cmt;
		$state=2;
	} elsif(($state==11 or $state==12) and (/^$/ or /^\s/)) {
		$state=12;
		s/^\t//;
		$cmt .= "$_\n";
	} elsif($state==12 and /^$/) {
		$cmt .= "$_\n";
		$state=12;
	} elsif($state==2 and /^$/) {
		$state=3;
	} elsif($state==3 and /^\.\.\./) {
		$state=4;
		isgone($_);
	} elsif($state==4 and /^\.\.\./) {
		isgone($_);
	} elsif($state==4 and /^$/) {
		$state=5;
	} elsif($state==5 and /^Differences/) {
		$state=6;
	} elsif($state==6 and /^$/) {
		$state=7;
		last;
	} else {
		die "Unbekannt: '$_'";
	}
}
die "Problem: Status $state" if $state != 7;
if($ENV{REV}) {
	open(P,"| patch -R -E -p1");
} else {
	open(P,"| patch -g1 -p1 -E -f");
}
print P $_ while(<STDIN>);
close(P) ;#or die "Patch close: $?";

exit(0) if $ENV{REV};


sub bkfiles($) {
	my($f) = @_;
	my @new = grep {
		 m#/SCCS/#
		? undef
		: 1
	} bk(sfiles=>"-U$f");
	@new;
}

my @new = grep { if(-l $_) { unlink $_; undef; } else { 1; } } bkfiles("x");
my @cur = ();
my @gone = grep { not -e $_ } bkfiles("g");

if(@new and @gone) {
	bk(get=>"-qeg",@gone);
	open(RN,"| env @DT bk renametool");
	foreach my $f(sort { $a cmp $b } @gone) { print RN "$f\n"; }
	print RN "\n";
	foreach my $f(sort { $a cmp $b } @new) { print RN "$f\n"; }
	close(RN);
	confess "No rename" if $?;
} elsif(@new) {
	bk(new => '-qG', "-yNew:@ARGV", @new);
} elsif(@gone) {
	bk(rm => @gone);
} else {
	open(CH,"bk -r diffs | head -1 |");
	my $ch = <CH>;
	close(CH);
	unless(defined $ch) {
		print STDERR "...no changes.\n";
		bk("-r","unlock","-f");
		exit 0;
	}
}

bk(ci => '-qG', "-y@ARGV", bkfiles("gl"));
# bk(undef,"bk sfiles -pC | env @DT bk cset -q -y\"$cmt\"");
#unlink("ChangeSet");
#unlink("SCCS/p.ChangeSet");
bk("clean","-q","ChangeSet");
open(FP,"|-") or do {
	$cmt =~ s/\001//g;
	print "bk sfiles -pC | env @DT bk cset -y[".length($cmt)."]\n";
	exec("env", @DT, "bk", "cset", "-y$cmt");
	exit(99);
};
open(P,"bk sfiles -pC |");
while(<P>) {
	print $_;
	print FP $_;
}
close(P); close(FP);



